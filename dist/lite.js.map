{
  "version": 3,
  "sources": ["../src/params.js", "../src/util.js", "../src/runtime/inspect.js", "../src/runtime/Reflex.js", "../src/runtime/Runtime.js", "../src/ReflexFunctionLite.js", "../src/targets.browser.lite.js"],
  "sourcesContent": ["\n/**\n * @exports\n */\nexport function resolveParams( ...extensions ) {\n    let params = { runtimeParams, compilerParams, parserParams }, extension;\n    while( extension = extensions.shift() ) {\n        const {\n            runtimeParams: _runtimeParams = {},\n            compilerParams: { globalsNoObserve: _globalsNoObserve = [], globalsOnlyPathsExcept: _globalsOnlyPathsExcept = [], ..._compilerParams } = {},\n            parserParams: _parserParams = {},\n        } = extension;\n        params = {\n            runtimeParams: { ...params.runtimeParams, ..._runtimeParams },\n            compilerParams: { ...params.compilerParams, globalsNoObserve: [ ...params.compilerParams.globalsNoObserve, ..._globalsNoObserve ], globalsOnlyPathsExcept: [ ...params.compilerParams.globalsOnlyPathsExcept, ..._globalsOnlyPathsExcept ], ..._compilerParams },\n            parserParams: { ...params.parserParams, ..._parserParams },\n        };\n        if ( extensions.devMode ) { /* shortcut for devMode configs */ }\n    }\n    return params;\n}\nexport const parserParams = {\n    ecmaVersion: '2020',\n    allowReturnOutsideFunction: true,\n    allowAwaitOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    preserveParens: false,\n    locations: false,\n};\nexport const compilerParams = {\n    globalsNoObserve: [ 'arguments', 'debugger', ],\n    globalsOnlyPathsExcept: [],\n    originalSource: true,\n    locations: true,\n    compact: 2,\n};\nexport const runtimeParams = {\n    apiVersion: 2,\n};\n", "\n/**\n * @normalizeTabs\n */\nexport  function normalizeTabs( rawSource, isFunc = false ) {\n    let rawSourceSplit = rawSource.split(/\\n/g);\n    if ( rawSourceSplit.length > 1 ) {\n        while ( !rawSourceSplit[ 0 ].trim().length ) rawSourceSplit.shift();\n        let possibleBodyIndentLevel = rawSourceSplit[ isFunc ? 1 : 0 ].split(/[^\\s]/)[ 0 ].length;\n        if ( possibleBodyIndentLevel ) {\n            return rawSourceSplit.map( ( line, i ) => {\n                let possibleIndent = line.substring( 0, possibleBodyIndentLevel );\n                if ( !possibleIndent.trim().length ) {\n                    return line.substring( possibleBodyIndentLevel );\n                }\n                // Last line?\n                if ( possibleIndent.trim() === '}' && i === rawSourceSplit.length - 1 ) {\n                    return '}';\n                }\n                return line;\n            } ).join( \"\\n\" );\n        }\n    }\n    return rawSource;\n}\n\nexport const _await = ( maybePromise, callback ) => (\n    maybePromise instanceof Promise ? maybePromise.then( callback ) : callback( maybePromise )\n);\n\nexport  const _compare = ( a, b ) => {\n    if ( typeof a === 'object' && a && typeof b === 'object' && b ) return _deepEql( a, b );\n    if ( Array.isArray( a ) && Array.isArray( b ) && a.length === b.length ) return a.every( valueA => b.some( valueB => _compare( valueA, valueB ) ) );\n    return a === b;\n};\n\nexport  const _deepEql = function( a, b ) {\n    for ( let key in a ) {\n        if ( !_compare( a[ key ], b[ key ] ) ) return false;\n    }\n    return true;\n};\n", "/**\n * @imports\n */\nimport { _await } from '../util.js';\n\n/**\n * @exports\n */\nconst store = new Map;\nexport default function( _function, arg ) {\n    if ( typeof arg === 'object' && arg ) {\n        store.set( _function, arg );\n        return;\n    }\n    const insp = store.get( _function );\n    return _await( insp, _insp => _insp && ( arg ? _insp[ arg ] : _insp ) );\n}", "\n/**\n * @imports\n */\nimport { _await } from '../util.js';\nimport inspection from './inspect.js';\n\nexport default class Reflex {\n\n    constructor( ownerReflex, graph, callee, params = {}, $thread = null, exits = null ) {\n        this.ownerReflex = ownerReflex;\n        this.graph = graph;\n        this.callee = callee;\n        this.params = !ownerReflex ? { ...params, isReflexFunction: true } : params;\n        this.exits = exits || new Map;\n        this.$thread = $thread || { entries: new Map, sequence: [], ownerReflex: this };\n        this.subReflexes = new Map;\n        this.observers = [];\n        this.reflex = function( reflexId, arg1, arg2 = null, arg3 = null ) {\n            if ( !this.graph.subReflexes[ reflexId ] ) {\n                throw new Error( `[${ this.graph.type }:${ this.graph.lineage }]: Graph not found for child reflex ${ reflexId }.` );\n            }\n\n            let subGraph = this.graph.subReflexes[ reflexId ];\n            let subParams = {\n                ...this.params,\n                isIterationReflex: arguments.length === 3,\n                iterationId: arguments.length === 3 && arg1,\n                isFunctionReflex: arguments.length === 4,\n                functionType: arguments.length === 4 && arg1,\n                isReflexFunction: arguments.length === 4 && arg2,\n                functionScope: ( this.params.isFunctionReflex && this.graph.lineage ) || this.params.functionScope,\n            };\n\n            if ( subParams.isIterationReflex ) {\n                // This is an iteration reflex\n                let callee = arg2;\n                // Create iteration\n                let iterationInstanceReflex = new Reflex( this, subGraph, callee, subParams, this.$thread, this.exits );\n                // Add iteration\n                let iterations = this.subReflexes.get( reflexId );\n                if ( !iterations ) {\n                    iterations = new Map;\n                    this.subReflexes.set( reflexId, iterations );\n                }\n                // Dispose all existing\n                if ( iterations.has( subParams.iterationId ) ) {\n                    iterations.get( subParams.iterationId ).dispose();\n                }\n                iterations.set( subParams.iterationId, iterationInstanceReflex );\n                return iterationInstanceReflex.call();\n            }\n\n            let callee, subReflex, returnValue;\n            // Dispose existing\n            if ( this.subReflexes.has( reflexId ) ) {\n                this.subReflexes.get( reflexId ).dispose();\n            }\n\n            if ( subParams.isFunctionReflex ) {\n                // Function reflexes\n                callee = arg3;\n                const createCallback = () => new Reflex( this, subGraph, callee, subParams );\n                if ( subParams.functionType !== 'FunctionDeclaration' ) {\n                    returnValue = this.createFunction( createCallback );\n                } else {\n                    let subReflex = createCallback();\n                    if ( subParams.apiVersion > 1 ) {\n                        returnValue = function( ...args ) {\n                            let _returnValue = subReflex.call( this, ...args );\n                            _returnValue = _await( _returnValue, __returnValue => [ _returnValue, subReflex.thread.bind( subReflex ), subReflex ] );\n                            subReflex = createCallback();\n                            return _returnValue;\n                        }\n                        returnValue.target = subReflex;\n                    } else {\n                        returnValue = subReflex;\n                    }\n                }\n            } else {\n                // Regular reflexes\n                callee = arg1, subReflex = new Reflex( this, subGraph, callee, subParams, this.$thread, this.exits );\n                this.subReflexes.set( reflexId, subReflex );\n                returnValue = subReflex.call();\n            }\n\n            return returnValue;\n        }.bind( this );\n        // ---------------------------\n        this.reflex.memo = Object.create( null );\n        if ( this.ownerReflex && ![ 'FunctionDeclaration', 'FunctionExpression' ].includes( this.graph.type ) ) {\n            this.reflex.args = this.ownerReflex.reflex.args;\n        }\n        // ---------------------------\n        this.reflex.exiting = function( keyword, arg ) {\n            if ( !arguments.length ) return this.exits.size;\n            let exitMatch = this.exits.get( keyword ) === arg;\n            if ( exitMatch ) this.exits.clear();\n            return exitMatch;\n        }.bind( this );\n        // ---------------------------\n        this.reflex.exit = function( keyword, arg ) {\n            this.exits.set( keyword, arg );\n        }.bind( this );\n        // ---------------------------\n        this.reflex.functions = new Map;\n        this.reflex.functions.declaration = ( functionDeclaration, callTarget ) => {\n            this.reflex.functions.set( functionDeclaration, callTarget );\n            this.applyReflection( functionDeclaration, typeof callTarget === 'function' ? callTarget.target : callTarget );\n        }\n    }\n\n    fire( reflexUrl, event, refs ) {\n        if ( !this.ownerReflex ) return;\n        const ret = this.ownerReflex.fire( reflexUrl, event, refs );\n        this.observers.forEach( observer => {\n            if ( observer.reflexUrl !== reflexUrl ) return;\n            observer.callback( event, refs );\n        } );\n        return ret;\n    }\n\n    observe( reflexUrl, callback ) {\n        if ( !this.params.isFunctionReflex ) return;\n        this.observers.push( { reflexUrl, callback } );\n    }\n\n    call( $this, ...$arguments ) {\n        if ( this.disposed ) {\n            throw new Error( `[${ this.graph.type }:${ this.graph.lineage }]: Instance not runable after having been disposed.` );\n        }\n        if ( !this.ownerReflex ) {\n            this.reflex.args = $arguments;\n            Object.defineProperty( this.reflex.args, Symbol.toStringTag, { value: 'Arguments' } );\n        }\n        let returnValue = this.callee.call( $this, this.reflex, ...$arguments );\n        if ( this.graph.$sideEffects ) {\n            for ( let referenceId in this.graph.effects ) {\n                for ( let effectRef of this.graph.effects[ referenceId ].refs ) {\n                    // Build side effects\n                    this.buildThread( [], effectRef, [], 0, true );\n                }\n            }\n        }\n        return _await( returnValue, () => {\n            if ( !this.ownerReflex || this.params.isFunctionReflex ) {\n                let exitReturnValue = this.exits.get( 'return' );\n                this.exits.clear();\n                if ( exitReturnValue !== undefined ) return exitReturnValue;\n            }\n            return returnValue;\n        } );\n    }\n\n    iterate( keys = [] ) {\n        if ( this.disposed ) return false;\n        if ( ![ 'ForOfStatement', 'ForInStatement' ].includes( this.graph.type ) || this.subReflexes.size !== 1 ) {\n            throw new Error( `Reflex ${ this.graph.lineage } is not an iterator.` );\n        }\n        let [ [ /* iterationReflexId */, iterationInstances ] ] = this.subReflexes;\n        let prev\n        if ( !keys.length || ( keys.includes( 'length' ) && this.graph.type === 'ForOfStatement' ) ) {\n            for ( let [ /* iterationId */, iterationInstance ] of iterationInstances ) {\n                prev = _await( prev, () => iterationInstance.call() );\n            }\n        } else {\n            for ( let key of keys ) {\n                let instance = iterationInstances.get( key ) || iterationInstances.get( parseInt( key ) );\n                if ( !instance ) continue;\n                prev = _await( prev, () => instance.call() );\n            }\n        }\n        return prev;\n    }\n\n    thread( ...eventRefs ) {\n        if ( this.disposed ) return false;\n        this.$thread.active = true;\n        for ( let referenceId in this.graph.effects ) {\n            for ( let effectRef of this.graph.effects[ referenceId ].refs ) {\n                for ( let eventRef of eventRefs ) {\n                    eventRef = Array.isArray( eventRef ) ? eventRef : [ eventRef ];\n                    let [ isMatch, remainder, computes ] = this.matchRefs( eventRef, effectRef );\n                    if ( !isMatch ) continue;\n                    this.buildThread( eventRef, effectRef, computes, remainder );\n                }\n            }\n        }\n        return this.runThread();\n    }\n\n    runThread() {\n        let execute = ( entry, refs ) => {\n            if ( [ 'ForOfStatement', 'ForInStatement' ].includes( entry.graph.type ) \n            && refs.every( ref => ref.executionPlan.isIterationReflexTarget ) ) {\n                let targets = refs.map( ref => ref.executionPlan.iterationTarget );\n                this.fire( entry.graph.lineage, 'iterating', refs );\n                return entry.iterate( targets );\n            }\n            this.fire( entry.graph.lineage, 'executing', refs );\n            return entry.call();\n        };\n        let prev, entry, refs;\n        while ( \n            ( entry = this.$thread.sequence.shift() ) \n            && ( refs = [ ...this.$thread.entries.get( entry ) ] ) \n            && this.$thread.entries.delete( entry ) // Important: to allow re-entry on susequent threads\n        ) {\n            prev = _await( prev, () => {\n                if ( entry.disposed || !entry.filterRefs( refs ).length ) return;\n                this.$thread.current = entry;\n                let maybePromise = execute( entry, refs );\n                _await( maybePromise, () => {\n                    for ( let ref of refs ) {\n                        [].concat( ref.executionPlan.assigneeRef || ref.executionPlan.assigneeRefs || [] ).forEach( assigneeRef => {\n                            entry.buildThread( [], assigneeRef, [], 0 );\n                        } );\n                    }\n                } );\n                return maybePromise;\n            } );\n        }\n        return _await( prev, () => {\n            let _ret = this.exits.get( 'return' );\n            this.exits.clear();\n            this.$thread.current = null;\n            this.$thread.active = false;\n            return _ret;\n        } );\n    }\n\n    buildThread( eventRef, effectRef, computes, remainder = 0, isSideEffect = false ) {\n        let shouldMatchEventRef = remainder > 0;\n        if ( this.ownerReflex ) {\n            // IMPORTANT: effectRef at global level are not supposed to be checked for computes and condition\n            if ( !this.compute( computes ) ) return;\n            if ( effectRef.condition !== undefined && !this.assert( effectRef.condition ) ) return;\n        } else if ( !shouldMatchEventRef ) {\n            shouldMatchEventRef = computes.length || effectRef.condition !== undefined;\n        }\n        let subscriptionsObject = isSideEffect ? effectRef.$subscriptions : effectRef.subscriptions;\n        // First we assert the conditions for the effectRef before moving on\n        Object.keys( subscriptionsObject ).forEach( fullReferenceUrl => {\n            let [ reflexUrl, referenceId ] = fullReferenceUrl.split( ':' );\n            let selectRefs = _subscriberInstance => {\n                if ( !_subscriberInstance ) return;\n                _subscriberInstance.selectRefs( referenceId, subscriptionsObject[ fullReferenceUrl ], shouldMatchEventRef ? eventRef : null );\n            }\n            // We find the subscriber instance\n            let subscriberInstance = this.locate( reflexUrl );\n            if ( Array.isArray( subscriberInstance ) ) {\n                subscriberInstance.forEach( selectRefs );\n            } else {\n                selectRefs( subscriberInstance );\n            }\n        } );\n    }\n\n    selectRefs( referenceId, refIds, eventRef = null ) {\n        // We'll select refs from within the following reference\n        let $thread = this.$thread;\n        let reference = this.graph.signals[ referenceId ];\n        // -----------------------------------------\n        let compare = ( a, b ) => a.graph.lineage.localeCompare( b.graph.lineage, undefined, { numeric: true } );\n        let selectRef = ( ref, computes = [], executionPlan = {} ) => {\n            // If this addition is by the side effect of a function, \"this\" can sometimes be higher in scope\n            if ( !$thread.active ) return;\n            if ( $thread.current && compare( this, $thread.current ) < 0 ) return;\n            let refs = $thread.entries.get( this );\n            if ( !refs ) {\n                refs = new Set;\n                $thread.entries.set( this, refs );\n                $thread.sequence.push( this );\n                $thread.sequence.sort( compare );\n            }\n            refs.add( { ...ref, computes, executionPlan } );\n            if ( !executionPlan.assigneeRef && [ 'VariableDeclaration', 'AssignmentExpression' ].includes( this.graph.type ) ) {\n                executionPlan.assigneeRefs = [];\n                for ( let referenceId in this.graph.effects ) {\n                    executionPlan.assigneeRefs.push( ...this.graph.effects[ referenceId ].refs )\n                }\n            }\n        };\n        // -----------------------------------------\n        for ( let refId of refIds ) {\n            // The ref within reference\n            let ref = reference.refs[ refId ];\n            // First we assert the conditions for the ref before moving on\n            if ( !eventRef ) {\n                // AffectedRef matched event ref... So we select ALL refs within reference\n                selectRef( ref );\n                continue;\n            }\n            // We match ref to decide whether or how to select it\n            let [ isMatch_b, remainder_b, computes_b ] = this.matchRefs( eventRef, ref );\n            if ( !isMatch_b ) continue;\n            if ( remainder_b <= 0 ) {\n                // SubscriberRef matches event ref\n                selectRef( ref, computes_b );\n                continue;\n            }\n            let eventRef_balance = eventRef.slice( -remainder_b );\n            let assigneeReference = 'assignee' in reference ? this.graph.effects[ reference.assignee ] : null;\n            if ( assigneeReference ) {\n                assigneeReference.refs.forEach( assigneeRef => {\n                    if ( assigneeRef.depth.length ) {\n                        let [ isMatch_c, remainder_c, computes_c ] = this.matchRefs( eventRef_balance, assigneeRef.depth );\n                        let computes_d = computes_b.concat( computes_c );\n                        if ( isMatch_c && remainder_c > 0 ) {\n                            // We move on passively to effects on the assignee\n                            let newEventRef = assigneeRef.path.concat( eventRef_balance.slice( -remainder_c ) );\n                            this.buildThread( newEventRef, assigneeRef, computes_d, remainder_c );\n                        } else if ( isMatch_c ) {\n                            // Match is successful on the destructuring side... so we select\n                            selectRef( ref, computes_d, { assigneeRef } );\n                        }\n                    } else {\n                        // We move on passively to effects on the assignee\n                        let newEventRef = assigneeRef.path.concat( eventRef_balance );\n                        this.buildThread( newEventRef, assigneeRef, computes_b, remainder_b );\n                    }\n                } );\n                continue;\n            }\n            if ( remainder_b === 1 && this.graph.type === 'ForOfStatement' ) {\n                // An iteration item was changed or the length property of the list was changed\n                selectRef( ref, computes_b, { isIterationReflexTarget: true, iterationTarget: eventRef_balance[ 0 ] } );\n                continue;\n            }\n            if ( remainder_b === 1 && this.graph.type === 'ForInStatement' ) {\n                // An iteration property was changed\n                selectRef( ref, computes_b, { isIterationReflexTarget: true, iterationTarget: eventRef_balance[ 0 ] } );\n                continue;\n            }\n        }\n    }\n\n    filterRefs( refs ) {\n        return refs.filter( ref => {\n            if ( !this.compute( ref.computes ) ) return;\n            if ( ref.condition !== undefined && !this.assert( ref.condition ) ) return;\n            return true;\n        } );\n    }\n\n    matchRefs( a, b ) {\n        let pathA, $pathA, pathB, $pathB;\n        if ( Array.isArray( a ) ) {\n            pathA = a, $pathA = a.dotSafe ? a.join( '.' ) : undefined;\n        } else {\n            pathA = a.path, $pathA = a.$path;\n        }\n        if ( Array.isArray( b ) ) {\n            pathB = b, $pathB = b.dotSafe ? b.join( '.' ) : undefined;\n        } else {\n            pathB = b.path, $pathB = b.$path;\n        }\n        let remainder = pathA.length - pathB.length;\n        if ( remainder > 0 ) {\n            [ pathA, pathB, $pathA, $pathB ] = [ pathB, pathA, $pathB, $pathA ];\n        }\n        if ( $pathA && $pathB ) {\n            return [ `${ $pathB }.`.startsWith( `${ $pathA }.` ), remainder, [] ];\n        }\n        let computes = [];\n        let getVal = element => ( typeof element === 'object' ? element.name : element );\n        let compareIdentifiers = ( a, b ) => {\n            if ( !a || !b ) return false;\n            let isComputeA = typeof a === 'object' && ( 'memoId' in a ),\n                isComputeB = typeof b === 'object' && ( 'memoId' in b );\n            if ( isComputeA || isComputeB ) {\n                computes.push( memo => {\n                    return ( isComputeA ? memo[ a.memoId ] : getVal( a ) ) === ( isComputeB ? memo[ b.memoId ] : getVal( b ) ) \n                } );\n                return true;\n            }\n            return getVal( a ) === getVal( b );\n        };\n        return [\n            pathA.reduce( ( prev, identifier, i ) => prev && compareIdentifiers( identifier, pathB[ i ] ), true ),\n            remainder,\n            computes,\n        ];\n    }\n\n    locate( reflexUrl ) {\n        let ownLineage_ = this.graph.lineage + '/';\n        let reflexUrl_ = reflexUrl + '/';\n        if ( reflexUrl_ === ownLineage_ ) return this;\n        if ( reflexUrl_.startsWith( ownLineage_ ) ) {\n            let postLineage = reflexUrl.slice( ownLineage_.length ).split( '/' );\n            let subReflex = this.subReflexes.get( parseInt( postLineage.shift() ) );\n            if ( postLineage.length) {\n                if ( subReflex instanceof Map ) {\n                    return Array.from( subReflex ).reduce( ( subReflexes, [ key, _subReflex ] ) => {\n                        return subReflexes.concat( _subReflex.locate( reflexUrl ) );\n                    }, [] );\n                }\n                if ( subReflex ) {\n                    return subReflex.locate( reflexUrl );\n                }\n            }\n            return subReflex;\n        }\n        if ( this.ownerReflex ) {\n            return this.ownerReflex.locate( reflexUrl );\n        }\n    }\n\n    compute( computes ) {\n        return !computes.some( compute => compute( this.reflex.memo ) === false );\n    }\n\n    assert( condition ) {\n        if ( typeof condition === 'string' && condition.includes( ':' ) ) {\n            let [ reflexUrl, _condition ] = condition.split( ':' );\n            return this.locate( reflexUrl ).assert( _condition );\n        }\n        let conditionDef = this.graph.conditions[ condition ];\n        let memo = this.reflex.memo;\n        if ( typeof conditionDef.parent !== 'undefined'  && !this.assert( conditionDef.parent ) ) return false;\n        if ( typeof conditionDef.switch !== 'undefined' ) {\n            return conditionDef.cases.some( _case => memo[ _case ] === memo[ conditionDef.switch ] );\n        }\n        if ( typeof conditionDef.whenNot !== 'undefined' ) {\n            return !memo[ conditionDef.whenNot ];\n        }\n        if ( typeof conditionDef.when !== 'undefined' ) {\n            return memo[ conditionDef.when ];\n        }\n        return true;\n    }\n\n    dispose() {\n        if ( this.params.isFunctionReflex ) return;\n        this.subReflexes.forEach( ( subReflex, reflexId ) => {\n            if ( subReflex instanceof Map ) {\n                subReflex.forEach( subReflex => subReflex.dispose() );\n                subReflex.clear();\n            } else {\n                subReflex.dispose();\n            }\n        } );\n        this.subReflexes.clear();\n        delete this.ownerReflex;\n        delete this.callee;\n        delete this.params;\n        delete this.reflex.memo;\n        this.disposed = true;\n    }\n    \n    createFunction( createCallback, defaultThis = undefined ) {\n        let instance = createCallback();\n        // -------------\n        const execute = function( _instance, ...args ) {\n            let _returnValue = _instance.call( this === undefined ? defaultThis : this, ...args );\n            if ( _instance.params.isReflexFunction && _instance.params.apiVersion > 1 ) {\n                _returnValue = _await( _returnValue, __returnValue => [ __returnValue, _instance.thread.bind( _instance ), _instance ] );\n                // Replace global for next call\n                instance = createCallback( instance );\n            }\n            return _returnValue;\n        };\n        // -------------\n        const _function = ( instance instanceof Promise ) || ( instance.callee instanceof ( async function() {} ).constructor )\n            ? async function() { return _await( instance, _instance => execute.call( this, _instance, ...arguments ) ); } \n            : function() { return execute.call( this, instance, ...arguments ); };\n        // -------------\n        _await( instance, _instance => {\n            this.applyReflection( _function, _instance );\n        } );\n        // -------------\n        inspection( _function, _await( instance, _instance => {\n            const graph = {\n                type: _instance.params.functionType || 'Program',\n                apiVersion: _instance.params.apiVersion || 1,\n                isReflexFunction: _instance.params.isReflexFunction,\n                sideEffects: _instance.graph.sideEffects || false,\n                locations: _instance.graph.locations || [],\n            };\n            if ( _instance.params.isReflexFunction ) {\n                graph.dependencies = [];\n                for ( const [ id, effect ] of Object.entries( _instance.graph.effects ) ) {\n                    graph.dependencies.push( ...effect.refs.map( ref => ref.path.map( s => !( 'name' in s ) ? Infinity : s.name ) ) );\n                }\n            }\n            return graph;\n        } ) );\n        // -------------\n        return _function;\n    }\n\n    applyReflection( _function, instance ) {\n        // Hide implementation details on callee\n        Object.defineProperty( instance.callee, 'length', { configurable: true, value: instance.callee.length - 1 } );\n        const compiledSourceNeat = instance.callee.toString()//.replace( /\\(\\$[\\w]+\\,([\\s]*)?/, '(' );\n        Object.defineProperty( instance.callee, 'toString', { configurable: true, value: ( compiledSource = false ) => {\n            if ( !compiledSource && instance.graph.originalSource ) { return instance.graph.originalSource; }\n            return compiledSourceNeat;\n        } } );\n        // Hide implementation details on main\n        let properties = {\n            name: instance.callee.name,\n            length: instance.callee.length,\n            toString: instance.callee.toString,\n        };\n        if ( instance.params.isReflexFunction ) {\n            if ( !( instance.params.apiVersion > 1 ) ) {\n                properties = {\n                    ...properties,\n                    thread: instance.thread.bind( instance ),\n                    dispose: instance.dispose.bind( instance ),\n                    runtime: instance,\n                };\n            }\n        }\n        Object.keys( properties ).forEach( name => {\n            Object.defineProperty( _function, name, { configurable: true, value: properties[ name ] } );\n        } );\n    }\n\n}\n", "\n/**\n * @imports\n */\nimport { _await } from '../util.js';\nimport Reflex from './Reflex.js';\n\nexport default class Runtime extends Reflex {\n\n    static create( compilation, parameters = [], runtimeParams = {} ) {\n        const isAsync = runtimeParams.async || compilation.graph.hoistedAwaitKeyword;\n        const _Function = isAsync ? Object.getPrototypeOf( async function() {} ).constructor : Function;\n        const callee = runtimeParams.compileFunction \n            ? runtimeParams.compileFunction( compilation.source, [ compilation.identifier + '' ].concat( parameters ) )\n            : new _Function( compilation.identifier + '', ...parameters, compilation.source );\n        compilation.graph.locations = compilation.locations;\n        return new this( null, compilation.graph, callee, runtimeParams );\n    }\n\n    static createFunction( sourceName, compilation, parameters = [], runtimeParams = {}, defaultThis, originalSource = null ) {\n        runtimeParams = { ...runtimeParams, functionType: 'Constructor', };\n        if ( compilation instanceof Promise ) { runtimeParams = { ...runtimeParams, async: true, }; }\n        const createCallback = instance => {\n            // Subsequent calls avoid recompilation\n            if ( instance ) { return new this( null, instance.graph, instance.callee, runtimeParams ); }\n            // Supports lazy compilation. So, input compilation may be a Promise\n            return _await( compilation, _compilation => applyReflection( this.create( _compilation, parameters, runtimeParams ) ) );\n        };\n        const applyReflection = instance => {\n            if ( instance.graph.originalSource && !instance.graph.originalSourceModified ) {\n                const ownSource = `${ runtimeParams.async || instance.graph.hoistedAwaitKeyword ? 'async ' : '' }function ${ sourceName || 'anonymous' }`;\n                const originalSourceIndented = instance.graph.originalSource.split(/\\n/g).map( line => `    ${ line }` ).join( `\\n` );\n                instance.graph.originalSource = `${ ownSource }(${ parameters.join( ', ' ) }) {\\n${ originalSourceIndented }\\n}`;\n                instance.graph.originalSourceModified = true;\n            }\n            if ( sourceName ) { Object.defineProperty( instance.callee, 'name', { configurable: true, value: sourceName } ); }\n            return instance;\n        };\n        return this.prototype.createFunction( createCallback, defaultThis );\n    }\n\n}", "\n/**\n * @imports\n */\nimport { resolveParams } from './params.js';\nimport { normalizeTabs } from './util.js';\nimport Runtime from './runtime/Runtime.js';\nimport inspect from './runtime/inspect.js';\n\n/**\n * @ReflexFunctionLite\n */\nexport default function ReflexFunctionLite( ...args ) {\n    if ( typeof window !== 'object' ) throw new Error( `No window in context.` );\n    // --------------------\n    const params = resolveParams( typeof args[ args.length - 1 ] === 'object' ? args.pop() : {} );\n    const source = normalizeTabs( args.pop() || '' );\n    const parameters = args;\n    const createFunction = compilation => Runtime.createFunction( undefined, compilation, parameters, params.runtimeParams, this, source );\n    // --------------------\n    // ReflexCompiler has been loaded sync?\n    if ( window.webqit?.ReflexCompiler && !params.runtimeParams.async ) {\n        const { parse, compile } = window.webqit.ReflexCompiler;\n        const ast = parse( source, params.parserParams );\n        return createFunction( compile( ast, params.compilerParams ) );\n    }\n    window.webqit = window.webqit || {};\n    // Load and run ReflexCompiler async - in the background?\n    if ( !window.webqit.ReflexCompilerWorker ) {\n        const customUrl = document.querySelector( 'meta[name=\"reflex-compiler-url\"]' );\n        const compilerUrls = ( customUrl?.content.split( ',' ) || [] ).concat( 'https://unpkg.com/@webqit/reflex-functions/dist/compiler.js' );\n        const workerScriptText = `\n        const compilerUrls = [ '${ compilerUrls.join( `','` ) }' ];\n        ( function importScript() {\n            try { importScripts( compilerUrls.shift().trim() ) } catch( e ) { if ( compilerUrls.length ) { importScript(); } }\n        } )();\n        const { parse, compile } = self.webqit.ReflexCompiler;\n        self.onmessage = e => {\n            const { source, params } = e.data;\n            const ast = parse( source, params.parserParams );\n            const compilation = compile( ast, params.compilerParams );\n            compilation.identifier = compilation.identifier.toString();\n            e.ports[ 0 ]?.postMessage( compilation );\n        };`;\n        window.webqit.ReflexCompilerWorker = new Worker( `data:text/javascript;base64,${ btoa( workerScriptText ) }` );\n    }\n    return createFunction( new Promise( res => {\n        let messageChannel = new MessageChannel;\n        webqit.ReflexCompilerWorker.postMessage( { source, params }, [ messageChannel.port2 ] );\n        messageChannel.port1.onmessage = e => res( e.data );\n    } ) );\n}\n\n/**\n * @inspect\n */\nObject.defineProperty( ReflexFunctionLite, 'inspect', { value: inspect } );\n", "\n/**\n * @imports\n */\nimport ReflexFunctionLite from './ReflexFunctionLite.js';\n\n// As globals\nif ( !self.webqit ) { self.webqit = {}; }\nself.webqit.ReflexFunction = ReflexFunctionLite;\n"],
  "mappings": "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",
  "names": ["resolveParams", "extensions", "params", "runtimeParams", "compilerParams", "parserParams", "extension", "_runtimeParams", "_globalsNoObserve", "_globalsOnlyPathsExcept", "_compilerParams", "_parserParams", "normalizeTabs", "rawSource", "isFunc", "rawSourceSplit", "possibleBodyIndentLevel", "line", "i", "possibleIndent", "_await", "maybePromise", "callback", "store", "inspect_default", "_function", "arg", "insp", "_await", "_insp", "Reflex", "ownerReflex", "graph", "callee", "params", "$thread", "exits", "reflexId", "arg1", "arg2", "arg3", "subGraph", "subParams", "iterationInstanceReflex", "iterations", "subReflex", "returnValue", "createCallback", "args", "_returnValue", "_await", "__returnValue", "keyword", "arg", "exitMatch", "functionDeclaration", "callTarget", "reflexUrl", "event", "refs", "ret", "observer", "callback", "$this", "$arguments", "referenceId", "effectRef", "exitReturnValue", "keys", "iterationInstances", "prev", "iterationInstance", "key", "instance", "eventRefs", "eventRef", "isMatch", "remainder", "computes", "execute", "entry", "ref", "targets", "maybePromise", "assigneeRef", "_ret", "isSideEffect", "shouldMatchEventRef", "subscriptionsObject", "fullReferenceUrl", "selectRefs", "_subscriberInstance", "subscriberInstance", "refIds", "reference", "compare", "a", "b", "selectRef", "executionPlan", "refId", "isMatch_b", "remainder_b", "computes_b", "eventRef_balance", "assigneeReference", "isMatch_c", "remainder_c", "computes_c", "computes_d", "newEventRef", "pathA", "$pathA", "pathB", "$pathB", "getVal", "element", "compareIdentifiers", "isComputeA", "isComputeB", "memo", "identifier", "i", "ownLineage_", "reflexUrl_", "postLineage", "subReflexes", "_subReflex", "compute", "condition", "_condition", "conditionDef", "_case", "defaultThis", "_instance", "_function", "inspect_default", "id", "effect", "s", "compiledSourceNeat", "compiledSource", "properties", "name", "Runtime", "Reflex", "compilation", "parameters", "runtimeParams", "_Function", "callee", "sourceName", "defaultThis", "originalSource", "createCallback", "instance", "_await", "_compilation", "applyReflection", "ownSource", "originalSourceIndented", "line", "ReflexFunctionLite", "args", "params", "resolveParams", "source", "normalizeTabs", "parameters", "createFunction", "compilation", "Runtime", "parse", "compile", "ast", "workerScriptText", "res", "messageChannel", "e", "inspect_default", "ReflexFunctionLite"]
}
