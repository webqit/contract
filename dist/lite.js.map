{
  "version": 3,
  "sources": ["../src/params.js", "../src/util.js", "../src/runtime/inspect.js", "../src/runtime/Contract.js", "../src/runtime/Runtime.js", "../src/SubscriptFunctionLite.js", "../src/targets.browser.lite.js"],
  "sourcesContent": ["\r\n/**\r\n * @exports\r\n */\r\nexport function resolveParams( ...extensions ) {\r\n    let params = { runtimeParams, compilerParams, parserParams }, extension;\r\n    while( extension = extensions.shift() ) {\r\n        const {\r\n            runtimeParams: _runtimeParams = {},\r\n            compilerParams: { globalsNoObserve: _globalsNoObserve = [], globalsOnlyPathsExcept: _globalsOnlyPathsExcept = [], ..._compilerParams } = {},\r\n            parserParams: _parserParams = {},\r\n        } = extension;\r\n        params = {\r\n            runtimeParams: { ...params.runtimeParams, ..._runtimeParams },\r\n            compilerParams: { ...params.compilerParams, globalsNoObserve: [ ...params.compilerParams.globalsNoObserve, ..._globalsNoObserve ], globalsOnlyPathsExcept: [ ...params.compilerParams.globalsOnlyPathsExcept, ..._globalsOnlyPathsExcept ], ..._compilerParams },\r\n            parserParams: { ...params.parserParams, ..._parserParams },\r\n        };\r\n        if ( extensions.devMode ) { /* shortcut for devMode configs */ }\r\n    }\r\n    return params;\r\n}\r\nexport const parserParams = {\r\n    ecmaVersion: '2020',\r\n    allowReturnOutsideFunction: true,\r\n    allowAwaitOutsideFunction: true,\r\n    allowSuperOutsideMethod: true,\r\n    preserveParens: false,\r\n    locations: false,\r\n};\r\nexport const compilerParams = {\r\n    globalsNoObserve: [ 'globalThis', 'arguments', 'console', 'debugger', ],\r\n    globalsOnlyPathsExcept: [],\r\n    originalSource: true,\r\n    locations: true,\r\n    compact: 2,\r\n};\r\nexport const runtimeParams = {\r\n    apiVersion: 1,\r\n};\r\n", "\r\n/**\r\n * @normalizeTabs\r\n */\r\nexport  function normalizeTabs( rawSource, isFunc = false ) {\r\n    let rawSourceSplit = rawSource.split(/\\n/g);\r\n    if ( rawSourceSplit.length > 1 ) {\r\n        while ( !rawSourceSplit[ 0 ].trim().length ) rawSourceSplit.shift();\r\n        let possibleBodyIndentLevel = rawSourceSplit[ isFunc ? 1 : 0 ].split(/[^\\s]/)[ 0 ].length;\r\n        if ( possibleBodyIndentLevel ) {\r\n            return rawSourceSplit.map( ( line, i ) => {\r\n                let possibleIndent = line.substring( 0, possibleBodyIndentLevel );\r\n                if ( !possibleIndent.trim().length ) {\r\n                    return line.substring( possibleBodyIndentLevel );\r\n                }\r\n                // Last line?\r\n                if ( possibleIndent.trim() === '}' && i === rawSourceSplit.length - 1 ) {\r\n                    return '}';\r\n                }\r\n                return line;\r\n            } ).join( \"\\n\" );\r\n        }\r\n    }\r\n    return rawSource;\r\n}\r\n\r\nexport const _await = ( maybePromise, callback ) => (\r\n    maybePromise instanceof Promise ? maybePromise.then( callback ) : callback( maybePromise )\r\n);\r\n\r\nexport  const _compare = ( a, b ) => {\r\n    if ( typeof a === 'object' && a && typeof b === 'object' && b ) return _deepEql( a, b );\r\n    if ( Array.isArray( a ) && Array.isArray( b ) && a.length === b.length ) return a.every( valueA => b.some( valueB => _compare( valueA, valueB ) ) );\r\n    return a === b;\r\n};\r\n\r\nexport  const _deepEql = function( a, b ) {\r\n    for ( let key in a ) {\r\n        if ( !_compare( a[ key ], b[ key ] ) ) return false;\r\n    }\r\n    return true;\r\n};\r\n", "\r\n/**\r\n * @exports\r\n */\r\nconst store = new Map;\r\nexport default function( _function, property, value = undefined ) {\r\n    let insp = store.get( _function );\r\n    if ( arguments.length > 2 ) {\r\n        if ( !insp ) {\r\n            insp = new Map;\r\n            store.set( _function, insp );\r\n        }\r\n        insp.set( property, value );\r\n        return;\r\n    }\r\n    return insp && insp.get( property );\r\n}", "\r\n/**\r\n * @imports\r\n */\r\nimport { _await } from '../util.js';\r\nimport inspection from './inspect.js';\r\n\r\nexport default class Contract {\r\n\r\n    constructor( ownerContract, graph, callee, params = {}, $thread = null, exits = null ) {\r\n        this.ownerContract = ownerContract;\r\n        this.graph = graph;\r\n        this.callee = callee;\r\n        this.params = !ownerContract ? { ...params, isSubscriptFunction: true } : params;\r\n        this.exits = exits || new Map;\r\n        this.$thread = $thread || { entries: new Map, sequence: [], ownerContract: this };\r\n        this.subContracts = new Map;\r\n        this.observers = [];\r\n        this.contract = function( contractId, arg1, arg2 = null, arg3 = null ) {\r\n            if ( !this.graph.subContracts[ contractId ] ) {\r\n                throw new Error( `[${ this.graph.type }:${ this.graph.lineage }]: Graph not found for child contract ${ contractId }.` );\r\n            }\r\n\r\n            let subGraph = this.graph.subContracts[ contractId ];\r\n            let subParams = {\r\n                ...this.params,\r\n                isIterationContract: arguments.length === 3,\r\n                iterationId: arguments.length === 3 && arg1,\r\n                isFunctionContract: arguments.length === 4,\r\n                functionType: arguments.length === 4 && arg1,\r\n                isSubscriptFunction: arguments.length === 4 && arg2,\r\n                functionScope: ( this.params.isFunctionContract && this.graph.lineage ) || this.params.functionScope,\r\n            };\r\n\r\n            if ( subParams.isIterationContract ) {\r\n                // This is an iteration contract\r\n                let callee = arg2;\r\n                // Create iteration\r\n                let iterationInstanceContract = new Contract( this, subGraph, callee, subParams, this.$thread, this.exits );\r\n                // Add iteration\r\n                let iterations = this.subContracts.get( contractId );\r\n                if ( !iterations ) {\r\n                    iterations = new Map;\r\n                    this.subContracts.set( contractId, iterations );\r\n                }\r\n                // Dispose all existing\r\n                if ( iterations.has( subParams.iterationId ) ) {\r\n                    iterations.get( subParams.iterationId ).dispose();\r\n                }\r\n                iterations.set( subParams.iterationId, iterationInstanceContract );\r\n                return iterationInstanceContract.call();\r\n            }\r\n\r\n            let callee, subContract, returnValue;\r\n            // Dispose existing\r\n            if ( this.subContracts.has( contractId ) ) {\r\n                this.subContracts.get( contractId ).dispose();\r\n            }\r\n\r\n            if ( subParams.isFunctionContract ) {\r\n                // Function contracts\r\n                callee = arg3;\r\n                const createCallback = () => new Contract( this, subGraph, callee, subParams );\r\n                if ( subParams.functionType !== 'FunctionDeclaration' ) {\r\n                    returnValue = this.createFunction( createCallback );\r\n                } else {\r\n                    let subContract = createCallback();\r\n                    if ( subParams.apiVersion > 1 ) {\r\n                        returnValue = function( ...args ) {\r\n                            let _returnValue = subContract.call( this, ...args );\r\n                            _returnValue = _await( _returnValue, __returnValue => [ _returnValue, subContract.thread.bind( subContract ), subContract ] );\r\n                            subContract = createCallback();\r\n                            return _returnValue;\r\n                        }\r\n                        returnValue.target = subContract;\r\n                    } else {\r\n                        returnValue = subContract;\r\n                    }\r\n                }\r\n            } else {\r\n                // Regular contracts\r\n                callee = arg1, subContract = new Contract( this, subGraph, callee, subParams, this.$thread, this.exits );\r\n                this.subContracts.set( contractId, subContract );\r\n                returnValue = subContract.call();\r\n            }\r\n\r\n            return returnValue;\r\n        }.bind( this );\r\n        // ---------------------------\r\n        this.contract.memo = Object.create( null );\r\n        if ( this.ownerContract && ![ 'FunctionDeclaration', 'FunctionExpression' ].includes( this.graph.type ) ) {\r\n            this.contract.args = this.ownerContract.contract.args;\r\n        }\r\n        // ---------------------------\r\n        this.contract.exiting = function( keyword, arg ) {\r\n            if ( !arguments.length ) return this.exits.size;\r\n            let exitMatch = this.exits.get( keyword ) === arg;\r\n            if ( exitMatch ) this.exits.clear();\r\n            return exitMatch;\r\n        }.bind( this );\r\n        // ---------------------------\r\n        this.contract.exit = function( keyword, arg ) {\r\n            this.exits.set( keyword, arg );\r\n        }.bind( this );\r\n        // ---------------------------\r\n        this.contract.functions = new Map;\r\n        this.contract.functions.declaration = ( functionDeclaration, callTarget ) => {\r\n            this.contract.functions.set( functionDeclaration, callTarget );\r\n            this.applyReflection( functionDeclaration, typeof callTarget === 'function' ? callTarget.target : callTarget );\r\n        }\r\n    }\r\n\r\n    fire( contractUrl, event, refs ) {\r\n        if ( !this.ownerContract ) return;\r\n        const ret = this.ownerContract.fire( contractUrl, event, refs );\r\n        this.observers.forEach( observer => {\r\n            if ( observer.contractUrl !== contractUrl ) return;\r\n            observer.callback( event, refs );\r\n        } );\r\n        return ret;\r\n    }\r\n\r\n    observe( contractUrl, callback ) {\r\n        if ( !this.params.isFunctionContract ) return;\r\n        this.observers.push( { contractUrl, callback } );\r\n    }\r\n\r\n    call( $this, ...$arguments ) {\r\n        if ( this.disposed ) {\r\n            throw new Error( `[${ this.graph.type }:${ this.graph.lineage }]: Instance not runable after having been disposed.` );\r\n        }\r\n        if ( !this.ownerContract ) {\r\n            this.contract.args = $arguments;\r\n            Object.defineProperty( this.contract.args, Symbol.toStringTag, { value: 'Arguments' } );\r\n        }\r\n        let returnValue = this.callee.call( $this, this.contract, ...$arguments );\r\n        if ( this.graph.$sideEffects ) {\r\n            for ( let referenceId in this.graph.effects ) {\r\n                for ( let effectRef of this.graph.effects[ referenceId ].refs ) {\r\n                    // Build side effects\r\n                    this.buildThread( [], effectRef, [], 0, true );\r\n                }\r\n            }\r\n        }\r\n        return _await( returnValue, () => {\r\n            if ( !this.ownerContract || this.params.isFunctionContract ) {\r\n                let exitReturnValue = this.exits.get( 'return' );\r\n                this.exits.clear();\r\n                if ( exitReturnValue !== undefined ) return exitReturnValue;\r\n            }\r\n            return returnValue;\r\n        } );\r\n    }\r\n\r\n    iterate( keys = [] ) {\r\n        if ( this.disposed ) return false;\r\n        if ( ![ 'ForOfStatement', 'ForInStatement' ].includes( this.graph.type ) || this.subContracts.size !== 1 ) {\r\n            throw new Error( `Contract ${ this.graph.lineage } is not an iterator.` );\r\n        }\r\n        let [ [ /* iterationContractId */, iterationInstances ] ] = this.subContracts;\r\n        let prev\r\n        if ( !keys.length || ( keys.includes( 'length' ) && this.graph.type === 'ForOfStatement' ) ) {\r\n            for ( let [ /* iterationId */, iterationInstance ] of iterationInstances ) {\r\n                prev = _await( prev, () => iterationInstance.call() );\r\n            }\r\n        } else {\r\n            for ( let key of keys ) {\r\n                let instance = iterationInstances.get( key ) || iterationInstances.get( parseInt( key ) );\r\n                if ( !instance ) continue;\r\n                prev = _await( prev, () => instance.call() );\r\n            }\r\n        }\r\n        return prev;\r\n    }\r\n\r\n    thread( ...eventRefs ) {\r\n        if ( this.disposed ) return false;\r\n        this.$thread.active = true;\r\n        for ( let referenceId in this.graph.effects ) {\r\n            for ( let effectRef of this.graph.effects[ referenceId ].refs ) {\r\n                for ( let eventRef of eventRefs ) {\r\n                    let [ isMatch, remainder, computes ] = this.matchRefs( eventRef, effectRef );\r\n                    if ( !isMatch ) continue;\r\n                    this.buildThread( eventRef, effectRef, computes, remainder );\r\n                }\r\n            }\r\n        }\r\n        return this.runThread();\r\n    }\r\n\r\n    runThread() {\r\n        let execute = ( entry, refs ) => {\r\n            if ( [ 'ForOfStatement', 'ForInStatement' ].includes( entry.graph.type ) \r\n            && refs.every( ref => ref.executionPlan.isIterationContractTarget ) ) {\r\n                let targets = refs.map( ref => ref.executionPlan.iterationTarget );\r\n                this.fire( entry.graph.lineage, 'iterating', refs );\r\n                return entry.iterate( targets );\r\n            }\r\n            this.fire( entry.graph.lineage, 'executing', refs );\r\n            return entry.call();\r\n        };\r\n        let prev, entry, refs;\r\n        while ( \r\n            ( entry = this.$thread.sequence.shift() ) \r\n            && ( refs = [ ...this.$thread.entries.get( entry ) ] ) \r\n            && this.$thread.entries.delete( entry ) // Important: to allow re-entry on susequent threads\r\n        ) {\r\n            prev = _await( prev, () => {\r\n                if ( entry.disposed || !entry.filterRefs( refs ).length ) return;\r\n                this.$thread.current = entry;\r\n                let maybePromise = execute( entry, refs );\r\n                _await( maybePromise, () => {\r\n                    for ( let ref of refs ) {\r\n                        [].concat( ref.executionPlan.assigneeRef || ref.executionPlan.assigneeRefs || [] ).forEach( assigneeRef => {\r\n                            entry.buildThread( [], assigneeRef, [], 0 );\r\n                        } );\r\n                    }\r\n                } );\r\n                return maybePromise;\r\n            } );\r\n        }\r\n        return _await( prev, () => {\r\n            let _ret = this.exits.get( 'return' );\r\n            this.exits.clear();\r\n            this.$thread.current = null;\r\n            this.$thread.active = false;\r\n            return _ret;\r\n        } );\r\n    }\r\n\r\n    buildThread( eventRef, effectRef, computes, remainder = 0, isSideEffect = false ) {\r\n        let shouldMatchEventRef = remainder > 0;\r\n        if ( this.ownerContract ) {\r\n            // IMPORTANT: effectRef at global level are not supposed to be checked for computes and condition\r\n            if ( !this.compute( computes ) ) return;\r\n            if ( effectRef.condition !== undefined && !this.assert( effectRef.condition ) ) return;\r\n        } else if ( !shouldMatchEventRef ) {\r\n            shouldMatchEventRef = computes.length || effectRef.condition !== undefined;\r\n        }\r\n        let subscriptionsObject = isSideEffect ? effectRef.$subscriptions : effectRef.subscriptions;\r\n        // First we assert the conditions for the effectRef before moving on\r\n        Object.keys( subscriptionsObject ).forEach( fullReferenceUrl => {\r\n            let [ contractUrl, referenceId ] = fullReferenceUrl.split( ':' );\r\n            let selectRefs = _subscriberInstance => {\r\n                if ( !_subscriberInstance ) return;\r\n                _subscriberInstance.selectRefs( referenceId, subscriptionsObject[ fullReferenceUrl ], shouldMatchEventRef ? eventRef : null );\r\n            }\r\n            // We find the subscriber instance\r\n            let subscriberInstance = this.locate( contractUrl );\r\n            if ( Array.isArray( subscriberInstance ) ) {\r\n                subscriberInstance.forEach( selectRefs );\r\n            } else {\r\n                selectRefs( subscriberInstance );\r\n            }\r\n        } );\r\n    }\r\n\r\n    selectRefs( referenceId, refIds, eventRef = null ) {\r\n        // We'll select refs from within the following reference\r\n        let $thread = this.$thread;\r\n        let reference = this.graph.signals[ referenceId ];\r\n        // -----------------------------------------\r\n        let compare = ( a, b ) => a.graph.lineage.localeCompare( b.graph.lineage, undefined, { numeric: true } );\r\n        let selectRef = ( ref, computes = [], executionPlan = {} ) => {\r\n            // If this addition is by the side effect of a function, \"this\" can sometimes be higher in scope\r\n            if ( !$thread.active ) return;\r\n            if ( $thread.current && compare( this, $thread.current ) < 0 ) return;\r\n            let refs = $thread.entries.get( this );\r\n            if ( !refs ) {\r\n                refs = new Set;\r\n                $thread.entries.set( this, refs );\r\n                $thread.sequence.push( this );\r\n                $thread.sequence.sort( compare );\r\n            }\r\n            refs.add( { ...ref, computes, executionPlan } );\r\n            if ( !executionPlan.assigneeRef && [ 'VariableDeclaration', 'AssignmentExpression' ].includes( this.graph.type ) ) {\r\n                executionPlan.assigneeRefs = [];\r\n                for ( let referenceId in this.graph.effects ) {\r\n                    executionPlan.assigneeRefs.push( ...this.graph.effects[ referenceId ].refs )\r\n                }\r\n            }\r\n        };\r\n        // -----------------------------------------\r\n        for ( let refId of refIds ) {\r\n            // The ref within reference\r\n            let ref = reference.refs[ refId ];\r\n            // First we assert the conditions for the ref before moving on\r\n            if ( !eventRef ) {\r\n                // AffectedRef matched event ref... So we select ALL refs within reference\r\n                selectRef( ref );\r\n                continue;\r\n            }\r\n            // We match ref to decide whether or how to select it\r\n            let [ isMatch_b, remainder_b, computes_b ] = this.matchRefs( eventRef, ref );\r\n            if ( !isMatch_b ) continue;\r\n            if ( remainder_b <= 0 ) {\r\n                // SubscriberRef matches event ref\r\n                selectRef( ref, computes_b );\r\n                continue;\r\n            }\r\n            let eventRef_balance = eventRef.slice( -remainder_b );\r\n            let assigneeReference = 'assignee' in reference ? this.graph.effects[ reference.assignee ] : null;\r\n            if ( assigneeReference ) {\r\n                assigneeReference.refs.forEach( assigneeRef => {\r\n                    if ( assigneeRef.depth.length ) {\r\n                        let [ isMatch_c, remainder_c, computes_c ] = this.matchRefs( eventRef_balance, assigneeRef.depth );\r\n                        let computes_d = computes_b.concat( computes_c );\r\n                        if ( isMatch_c && remainder_c > 0 ) {\r\n                            // We move on passively to effects on the assignee\r\n                            let newEventRef = assigneeRef.path.concat( eventRef_balance.slice( -remainder_c ) );\r\n                            this.buildThread( newEventRef, assigneeRef, computes_d, remainder_c );\r\n                        } else if ( isMatch_c ) {\r\n                            // Match is successful on the destructuring side... so we select\r\n                            selectRef( ref, computes_d, { assigneeRef } );\r\n                        }\r\n                    } else {\r\n                        // We move on passively to effects on the assignee\r\n                        let newEventRef = assigneeRef.path.concat( eventRef_balance );\r\n                        this.buildThread( newEventRef, assigneeRef, computes_b, remainder_b );\r\n                    }\r\n                } );\r\n                continue;\r\n            }\r\n            if ( remainder_b === 1 && this.graph.type === 'ForOfStatement' ) {\r\n                // An iteration item was changed or the length property of the list was changed\r\n                selectRef( ref, computes_b, { isIterationContractTarget: true, iterationTarget: eventRef_balance[ 0 ] } );\r\n                continue;\r\n            }\r\n            if ( remainder_b === 1 && this.graph.type === 'ForInStatement' ) {\r\n                // An iteration property was changed\r\n                selectRef( ref, computes_b, { isIterationContractTarget: true, iterationTarget: eventRef_balance[ 0 ] } );\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n\r\n    filterRefs( refs ) {\r\n        return refs.filter( ref => {\r\n            if ( !this.compute( ref.computes ) ) return;\r\n            if ( ref.condition !== undefined && !this.assert( ref.condition ) ) return;\r\n            return true;\r\n        } );\r\n    }\r\n\r\n    matchRefs( a, b ) {\r\n        let pathA, $pathA, pathB, $pathB;\r\n        if ( Array.isArray( a ) ) {\r\n            pathA = a, $pathA = a.dotSafe ? a.join( '.' ) : undefined;\r\n        } else {\r\n            pathA = a.path, $pathA = a.$path;\r\n        }\r\n        if ( Array.isArray( b ) ) {\r\n            pathB = b, $pathB = b.dotSafe ? b.join( '.' ) : undefined;\r\n        } else {\r\n            pathB = b.path, $pathB = b.$path;\r\n        }\r\n        let remainder = pathA.length - pathB.length;\r\n        if ( remainder > 0 ) {\r\n            [ pathA, pathB, $pathA, $pathB ] = [ pathB, pathA, $pathB, $pathA ];\r\n        }\r\n        if ( $pathA && $pathB ) {\r\n            return [ `${ $pathB }.`.startsWith( `${ $pathA }.` ), remainder, [] ];\r\n        }\r\n        let computes = [];\r\n        let getVal = element => ( typeof element === 'object' ? element.name : element );\r\n        let compareIdentifiers = ( a, b ) => {\r\n            if ( !a || !b ) return false;\r\n            let isComputeA = typeof a === 'object' && ( 'memoId' in a ),\r\n                isComputeB = typeof b === 'object' && ( 'memoId' in b );\r\n            if ( isComputeA || isComputeB ) {\r\n                computes.push( memo => {\r\n                    return ( isComputeA ? memo[ a.memoId ] : getVal( a ) ) === ( isComputeB ? memo[ b.memoId ] : getVal( b ) ) \r\n                } );\r\n                return true;\r\n            }\r\n            return getVal( a ) === getVal( b );\r\n        };\r\n        return [\r\n            pathA.reduce( ( prev, identifier, i ) => prev && compareIdentifiers( identifier, pathB[ i ] ), true ),\r\n            remainder,\r\n            computes,\r\n        ];\r\n    }\r\n\r\n    locate( contractUrl ) {\r\n        let ownLineage_ = this.graph.lineage + '/';\r\n        let contractUrl_ = contractUrl + '/';\r\n        if ( contractUrl_ === ownLineage_ ) return this;\r\n        if ( contractUrl_.startsWith( ownLineage_ ) ) {\r\n            let postLineage = contractUrl.slice( ownLineage_.length ).split( '/' );\r\n            let subContract = this.subContracts.get( parseInt( postLineage.shift() ) );\r\n            if ( postLineage.length) {\r\n                if ( subContract instanceof Map ) {\r\n                    return Array.from( subContract ).reduce( ( subContracts, [ key, _subContract ] ) => {\r\n                        return subContracts.concat( _subContract.locate( contractUrl ) );\r\n                    }, [] );\r\n                }\r\n                if ( subContract ) {\r\n                    return subContract.locate( contractUrl );\r\n                }\r\n            }\r\n            return subContract;\r\n        }\r\n        if ( this.ownerContract ) {\r\n            return this.ownerContract.locate( contractUrl );\r\n        }\r\n    }\r\n\r\n    compute( computes ) {\r\n        return !computes.some( compute => compute( this.contract.memo ) === false );\r\n    }\r\n\r\n    assert( condition ) {\r\n        if ( typeof condition === 'string' && condition.includes( ':' ) ) {\r\n            let [ contractUrl, _condition ] = condition.split( ':' );\r\n            return this.locate( contractUrl ).assert( _condition );\r\n        }\r\n        let conditionDef = this.graph.conditions[ condition ];\r\n        let memo = this.contract.memo;\r\n        if ( typeof conditionDef.parent !== 'undefined'  && !this.assert( conditionDef.parent ) ) return false;\r\n        if ( typeof conditionDef.switch !== 'undefined' ) {\r\n            return conditionDef.cases.some( _case => memo[ _case ] === memo[ conditionDef.switch ] );\r\n        }\r\n        if ( typeof conditionDef.whenNot !== 'undefined' ) {\r\n            return !memo[ conditionDef.whenNot ];\r\n        }\r\n        if ( typeof conditionDef.when !== 'undefined' ) {\r\n            return memo[ conditionDef.when ];\r\n        }\r\n        return true;\r\n    }\r\n\r\n    dispose() {\r\n        if ( this.params.isFunctionContract ) return;\r\n        this.subContracts.forEach( ( subContract, contractId ) => {\r\n            if ( subContract instanceof Map ) {\r\n                subContract.forEach( subContract => subContract.dispose() );\r\n                subContract.clear();\r\n            } else {\r\n                subContract.dispose();\r\n            }\r\n        } );\r\n        this.subContracts.clear();\r\n        delete this.ownerContract;\r\n        delete this.callee;\r\n        delete this.params;\r\n        delete this.contract.memo;\r\n        this.disposed = true;\r\n    }\r\n    \r\n    createFunction( createCallback, defaultThis = undefined ) {\r\n        let contract = createCallback();\r\n        // -------------\r\n        const execute = function( _contract, ...args ) {\r\n            let _returnValue = _contract.call( this === undefined ? defaultThis : this, ...args );\r\n            if ( _contract.params.isSubscriptFunction && _contract.params.apiVersion > 1 ) {\r\n                _returnValue = _await( _returnValue, __returnValue => [ __returnValue, _contract.thread.bind( _contract ), _contract ] );\r\n                // Replace global for next call\r\n                contract = createCallback( contract );\r\n            }\r\n            return _returnValue;\r\n        };\r\n        // -------------\r\n        const _function = ( contract instanceof Promise ) || ( contract.callee instanceof ( async function() {} ).constructor )\r\n            ? async function() { return _await( contract, _contract => execute.call( this, _contract, ...arguments ) ); } \r\n            : function() { return execute.call( this, contract, ...arguments ); };\r\n        // -------------\r\n        _await( contract, _contract => {\r\n            this.applyReflection( _function, _contract );\r\n        } );\r\n        // -------------\r\n        inspection( _function, 'properties', _await( contract, _contract => {\r\n            const graph = {\r\n                type: _contract.params.functionType || 'Program',\r\n                apiVersion: _contract.params.apiVersion || 1,\r\n                isSubscriptFunction: _contract.params.isSubscriptFunction,\r\n                sideEffects: _contract.graph.sideEffects || false,\r\n            };\r\n            if ( _contract.params.isSubscriptFunction ) {\r\n                graph.dependencies = [];\r\n                for ( const [ id, effect ] of Object.entries( _contract.graph.effects ) ) {\r\n                    graph.dependencies.push( ...effect.refs.map( ref => ref.path.map( s => !( 'name' in s ) ? Infinity : s.name ) ) );\r\n                }\r\n            }\r\n            return graph;\r\n        } ) );\r\n        // -------------\r\n        return _function;\r\n    }\r\n\r\n    applyReflection( _function, contract ) {\r\n        // Hide implementation details on callee\r\n        Object.defineProperty( contract.callee, 'length', { configurable: true, value: contract.callee.length - 1 } );\r\n        const compiledSourceNeat = contract.callee.toString()//.replace( /\\(\\$[\\w]+\\,([\\s]*)?/, '(' );\r\n        Object.defineProperty( contract.callee, 'toString', { configurable: true, value: ( compiledSource = false ) => {\r\n            if ( !compiledSource && contract.graph.originalSource ) { return contract.graph.originalSource; }\r\n            return compiledSourceNeat;\r\n        } } );\r\n        // Hide implementation details on main\r\n        let properties = {\r\n            name: contract.callee.name,\r\n            length: contract.callee.length,\r\n            toString: contract.callee.toString,\r\n        };\r\n        if ( contract.params.isSubscriptFunction ) {\r\n            if ( !( contract.params.apiVersion > 1 ) ) {\r\n                properties = {\r\n                    ...properties,\r\n                    thread: contract.thread.bind( contract ),\r\n                    dispose: contract.dispose.bind( contract ),\r\n                    runtime: contract,\r\n                };\r\n            }\r\n        }\r\n        Object.keys( properties ).forEach( name => {\r\n            Object.defineProperty( _function, name, { configurable: true, value: properties[ name ] } );\r\n        } );\r\n    }\r\n\r\n}\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport { _await } from '../util.js';\r\nimport Contract from './Contract.js';\r\nimport inspection from './inspect.js';\r\n\r\nexport default class Runtime extends Contract {\r\n\r\n    static create( compilation, parameters = [], runtimeParams = {} ) {\r\n        const isAsync = runtimeParams.async || compilation.graph.hoistedAwaitKeyword;\r\n        const _Function = isAsync ? Object.getPrototypeOf( async function() {} ).constructor : Function;\r\n        const callee = runtimeParams.compileFunction \r\n            ? runtimeParams.compileFunction( compilation.source, [ compilation.identifier + '' ].concat( parameters ) )\r\n            : new _Function( compilation.identifier + '', ...parameters, compilation.source );\r\n        return new this( null, compilation.graph, callee, runtimeParams );\r\n    }\r\n\r\n    static createFunction( sourceName, compilation, parameters = [], runtimeParams = {}, defaultThis, originalSource = null ) {\r\n        runtimeParams = { ...runtimeParams, functionType: 'Constructor', };\r\n        if ( compilation instanceof Promise ) { runtimeParams = { ...runtimeParams, async: true, }; }\r\n        const createCallback = contract => {\r\n            // Subsequent calls avoid recompilation\r\n            if ( contract ) { return new this( null, contract.graph, contract.callee, runtimeParams ); }\r\n            // Supports lazy compilation. So, input compilation may be a Promise\r\n            return _await( compilation, _compilation => applyReflection( this.create( _compilation, parameters, runtimeParams ) ) );\r\n        };\r\n        const applyReflection = contract => { \r\n            if ( contract.graph.originalSource && !contract.graph.originalSourceModified ) {\r\n                const ownSource = `${ runtimeParams.async || contract.graph.hoistedAwaitKeyword ? 'async ' : '' }function ${ sourceName || 'anonymous' }`;\r\n                const originalSourceIndented = contract.graph.originalSource.split(/\\n/g).map( line => `    ${ line }` ).join( `\\n` );\r\n                contract.graph.originalSource = `${ ownSource }(${ parameters.join( ', ' ) }) {\\n${ originalSourceIndented }\\n}`;\r\n                contract.graph.originalSourceModified = true;\r\n            }\r\n            if ( sourceName ) { Object.defineProperty( contract.callee, 'name', { configurable: true, value: sourceName } ); }\r\n            return contract;\r\n        };\r\n        const _function = this.prototype.createFunction( createCallback, defaultThis );\r\n        inspection( _function, 'locations', _await( compilation, _compilation => ( {\r\n            locations: _compilation.locations,\r\n        } ) ) );\r\n        return _function;\r\n    }\r\n\r\n}", "\r\n/**\r\n * @imports\r\n */\r\nimport { resolveParams } from './params.js';\r\nimport { normalizeTabs } from './util.js';\r\nimport Runtime from './runtime/Runtime.js';\r\nimport inspect from './runtime/inspect.js';\r\n\r\n/**\r\n * @SubscriptFunctionLite\r\n */\r\nexport default function SubscriptFunctionLite( ...args ) {\r\n    if ( typeof window !== 'object' ) throw new Error( `No window in context.` );\r\n    // --------------------\r\n    const params = resolveParams( typeof args[ args.length - 1 ] === 'object' ? args.pop() : {} );\r\n    const source = normalizeTabs( args.pop() || '' );\r\n    const parameters = args;\r\n    const createFunction = compilation => Runtime.createFunction( undefined, compilation, parameters, params.runtimeParams, this, source );\r\n    // --------------------\r\n    // SubscriptCompiler has been loaded sync?\r\n    if ( window.wq?.SubscriptCompiler && !params.runtimeParams.async ) {\r\n        const { parse, compile } = window.wq.SubscriptCompiler;\r\n        const ast = parse( source, params.parserParams );\r\n        return createFunction( compile( ast, params.compilerParams ) );\r\n    }\r\n    // Load and run SubscriptCompiler async - in the background?\r\n    if ( !window.wq?.SubscriptCompilerWorker ) {\r\n        const customUrl = document.querySelector( 'meta[name=\"subscript-compiler-url\"]' );\r\n        const compilerUrl = customUrl?.content || `https://unpkg.com/@webqit/subscript/dist/compiler.js`;\r\n        const workerScriptText = `\r\n        importScripts( '${ compilerUrl }' );\r\n        const { parse, compile } = self.wq.SubscriptCompiler;\r\n        self.onmessage = e => {\r\n            const { source, params } = e.data;\r\n            const ast = parse( source, params.parserParams );\r\n            const compilation = compile( ast, params.compilerParams );\r\n            compilation.identifier = compilation.identifier.toString();\r\n            e.ports[ 0 ]?.postMessage( compilation );\r\n        };`;\r\n        window.wq = window.wq || {};\r\n        window.wq.SubscriptCompilerWorker = new Worker( `data:text/javascript;base64,${ btoa( workerScriptText ) }` );\r\n    }\r\n    return createFunction( new Promise( res => {\r\n        let messageChannel = new MessageChannel;\r\n        wq.SubscriptCompilerWorker.postMessage( { source, params }, [ messageChannel.port2 ] );\r\n        messageChannel.port1.onmessage = e => res( e.data );\r\n    } ) );\r\n}\r\n\r\n/**\r\n * @inspect\r\n */\r\nObject.defineProperty( SubscriptFunctionLite, 'inspect', { value: inspect } );\r\n", "\r\n/**\r\n * @imports\r\n */\r\nimport SubscriptFunctionLite from './SubscriptFunctionLite.js';\r\n\r\n// As globals\r\nif ( !self.wq ) { self.wq = {}; }\r\nself.wq.SubscriptFunction = SubscriptFunctionLite;\r\n"],
  "mappings": "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",
  "names": ["resolveParams", "extensions", "params", "runtimeParams", "compilerParams", "parserParams", "extension", "_runtimeParams", "_globalsNoObserve", "_globalsOnlyPathsExcept", "_compilerParams", "_parserParams", "normalizeTabs", "rawSource", "isFunc", "rawSourceSplit", "possibleBodyIndentLevel", "line", "i", "possibleIndent", "_await", "maybePromise", "callback", "store", "inspect_default", "_function", "property", "value", "insp", "Contract", "ownerContract", "graph", "callee", "params", "$thread", "exits", "contractId", "arg1", "arg2", "arg3", "subGraph", "subParams", "iterationInstanceContract", "iterations", "subContract", "returnValue", "createCallback", "args", "_returnValue", "_await", "__returnValue", "keyword", "arg", "exitMatch", "functionDeclaration", "callTarget", "contractUrl", "event", "refs", "ret", "observer", "callback", "$this", "$arguments", "referenceId", "effectRef", "exitReturnValue", "keys", "iterationInstances", "prev", "iterationInstance", "key", "instance", "eventRefs", "eventRef", "isMatch", "remainder", "computes", "execute", "entry", "ref", "targets", "maybePromise", "assigneeRef", "_ret", "isSideEffect", "shouldMatchEventRef", "subscriptionsObject", "fullReferenceUrl", "selectRefs", "_subscriberInstance", "subscriberInstance", "refIds", "reference", "compare", "a", "b", "selectRef", "executionPlan", "refId", "isMatch_b", "remainder_b", "computes_b", "eventRef_balance", "assigneeReference", "isMatch_c", "remainder_c", "computes_c", "computes_d", "newEventRef", "pathA", "$pathA", "pathB", "$pathB", "getVal", "element", "compareIdentifiers", "isComputeA", "isComputeB", "memo", "identifier", "i", "ownLineage_", "contractUrl_", "postLineage", "subContracts", "_subContract", "compute", "condition", "_condition", "conditionDef", "_case", "defaultThis", "contract", "_contract", "_function", "inspect_default", "id", "effect", "s", "compiledSourceNeat", "compiledSource", "properties", "name", "Runtime", "Contract", "compilation", "parameters", "runtimeParams", "_Function", "callee", "sourceName", "defaultThis", "originalSource", "createCallback", "contract", "_await", "_compilation", "applyReflection", "ownSource", "originalSourceIndented", "line", "_function", "inspect_default", "SubscriptFunctionLite", "args", "params", "resolveParams", "source", "normalizeTabs", "parameters", "createFunction", "compilation", "Runtime", "parse", "compile", "ast", "workerScriptText", "res", "messageChannel", "e", "inspect_default", "SubscriptFunctionLite"]
}
